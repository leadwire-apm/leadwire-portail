{
  "apm_user_geo" : {
    "description" : "Add user geo information for APM events",
    "processors" : [
      {
        "geoip" : {
          "on_failure" : [
            {
              "remove" : {
                "field" : "client.ip",
                "ignore_missing" : true,
                "ignore_failure" : true
              }
            }
          ],
          "database_file" : "GeoLite2-City.mmdb",
          "field" : "client.ip",
          "target_field" : "client.geo",
          "ignore_missing" : true
        }
      }
    ]
  },
  "filebeat-7.10.0-nginx-error-pipeline" : {
    "description" : "Pipeline for parsing the Nginx error logs",
    "processors" : [
      {
        "set" : {
          "field" : "event.ingested",
          "value" : "{{_ingest.timestamp}}"
        }
      },
      {
        "grok" : {
          "pattern_definitions" : {
            "GREEDYMULTILINE" : "(.|\n|\t)*"
          },
          "ignore_missing" : true,
          "field" : "message",
          "patterns" : [
            "%{DATA:nginx.error.time} \\[%{DATA:log.level}\\] %{NUMBER:process.pid:long}#%{NUMBER:process.thread.id:long}: (\\*%{NUMBER:nginx.error.connection_id:long} )?%{GREEDYMULTILINE:message}"
          ]
        }
      },
      {
        "rename" : {
          "field" : "@timestamp",
          "target_field" : "event.created"
        }
      },
      {
        "date" : {
          "formats" : [
            "yyyy/MM/dd H:m:s"
          ],
          "on_failure" : [
            {
              "append" : {
                "field" : "error.message",
                "value" : "{{ _ingest.on_failure_message }}"
              }
            }
          ],
          "if" : "ctx.event.timezone == null",
          "field" : "nginx.error.time",
          "target_field" : "@timestamp"
        }
      },
      {
        "date" : {
          "field" : "nginx.error.time",
          "target_field" : "@timestamp",
          "formats" : [
            "yyyy/MM/dd H:m:s"
          ],
          "timezone" : "{{ event.timezone }}",
          "on_failure" : [
            {
              "append" : {
                "field" : "error.message",
                "value" : "{{ _ingest.on_failure_message }}"
              }
            }
          ],
          "if" : "ctx.event.timezone != null"
        }
      },
      {
        "remove" : {
          "field" : "nginx.error.time"
        }
      },
      {
        "set" : {
          "value" : "event",
          "field" : "event.kind"
        }
      },
      {
        "append" : {
          "field" : "event.category",
          "value" : "web"
        }
      },
      {
        "append" : {
          "field" : "event.type",
          "value" : "error"
        }
      }
    ],
    "on_failure" : [
      {
        "set" : {
          "value" : "{{ _ingest.on_failure_message }}",
          "field" : "error.message"
        }
      }
    ]
  },
  "apm_ingest_timestamp" : {
    "description" : "Add an ingest timestamp for APM events",
    "processors" : [
      {
        "set" : {
          "if" : "ctx.processor?.event != 'span'",
          "field" : "event.ingested",
          "value" : "{{_ingest.timestamp}}"
        }
      }
    ]
  },
  "filebeat-7.10.0-haproxy-log-pipeline" : {
    "description" : "Pipeline for parsing HAProxy http, tcp and default logs. Requires the geoip plugin.",
    "processors" : [
      {
        "set" : {
          "field" : "event.ingested",
          "value" : "{{_ingest.timestamp}}"
        }
      },
      {
        "grok" : {
          "patterns" : [
            "%{HAPROXY_DATE:haproxy.request_date} %{IPORHOST:haproxy.source} %{PROG:process.name}(?:\\[%{POSINT:process.pid:long}\\])?: %{GREEDYDATA} %{IPORHOST:source.address}:%{POSINT:source.port:long} %{WORD} %{IPORHOST:destination.ip}:%{POSINT:destination.port:long} \\(%{WORD:haproxy.frontend_name}/%{WORD:haproxy.mode}\\)",
            "(%{NOTSPACE:process.name}\\[%{NUMBER:process.pid:long}\\]: )?%{IP:source.address}:%{NUMBER:source.port:long} \\[%{NOTSPACE:haproxy.request_date}\\] %{NOTSPACE:haproxy.frontend_name} %{NOTSPACE:haproxy.backend_name}/%{NOTSPACE:haproxy.server_name} %{NUMBER:haproxy.http.request.time_wait_ms:long}/%{NUMBER:haproxy.total_waiting_time_ms:long}/%{NUMBER:haproxy.connection_wait_time_ms:long}/%{NUMBER:haproxy.http.request.time_wait_without_data_ms:long}/%{NUMBER:temp.duration:long} %{NUMBER:http.response.status_code:long} %{NUMBER:haproxy.bytes_read:long} %{NOTSPACE:haproxy.http.request.captured_cookie} %{NOTSPACE:haproxy.http.response.captured_cookie} %{NOTSPACE:haproxy.termination_state} %{NUMBER:haproxy.connections.active:long}/%{NUMBER:haproxy.connections.frontend:long}/%{NUMBER:haproxy.connections.backend:long}/%{NUMBER:haproxy.connections.server:long}/%{NUMBER:haproxy.connections.retries:long} %{NUMBER:haproxy.server_queue:long}/%{NUMBER:haproxy.backend_queue:long} (\\{%{DATA:haproxy.http.request.captured_headers}\\} \\{%{DATA:haproxy.http.response.captured_headers}\\} |\\{%{DATA}\\} )?\"%{GREEDYDATA:haproxy.http.request.raw_request_line}\"",
            "(%{NOTSPACE:process.name}\\[%{NUMBER:process.pid:long}\\]: )?%{IP:source.address}:%{NUMBER:source.port:long} \\[%{NOTSPACE:haproxy.request_date}\\] %{NOTSPACE:haproxy.frontend_name}/%{NOTSPACE:haproxy.bind_name} %{GREEDYDATA:haproxy.error_message}",
            "%{HAPROXY_DATE} %{IPORHOST:haproxy.source} (%{NOTSPACE:process.name}\\[%{NUMBER:process.pid:long}\\]: )?%{IP:source.address}:%{NUMBER:source.port:long} \\[%{NOTSPACE:haproxy.request_date}\\] %{NOTSPACE:haproxy.frontend_name} %{NOTSPACE:haproxy.backend_name}/%{NOTSPACE:haproxy.server_name} %{NUMBER:haproxy.total_waiting_time_ms:long}/%{NUMBER:haproxy.connection_wait_time_ms:long}/%{NUMBER:temp.duration:long} %{NUMBER:haproxy.bytes_read:long} %{NOTSPACE:haproxy.termination_state} %{NUMBER:haproxy.connections.active:long}/%{NUMBER:haproxy.connections.frontend:long}/%{NUMBER:haproxy.connections.backend:long}/%{NUMBER:haproxy.connections.server:long}/%{NUMBER:haproxy.connections.retries:long} %{NUMBER:haproxy.server_queue:long}/%{NUMBER:haproxy.backend_queue:long}"
          ],
          "ignore_missing" : false,
          "pattern_definitions" : {
            "HAPROXY_DATE" : "(%{MONTHDAY}[/-]%{MONTH}[/-]%{YEAR}:%{HOUR}:%{MINUTE}:%{SECOND})|%{SYSLOGTIMESTAMP}"
          },
          "field" : "message"
        }
      },
      {
        "date" : {
          "if" : "ctx.event.timezone == null",
          "field" : "haproxy.request_date",
          "target_field" : "@timestamp",
          "formats" : [
            "dd/MMM/yyyy:HH:mm:ss.SSS",
            "MMM dd HH:mm:ss"
          ],
          "on_failure" : [
            {
              "append" : {
                "field" : "error.message",
                "value" : "{{ _ingest.on_failure_message }}"
              }
            }
          ]
        }
      },
      {
        "date" : {
          "target_field" : "@timestamp",
          "formats" : [
            "dd/MMM/yyyy:HH:mm:ss.SSS",
            "MMM dd HH:mm:ss"
          ],
          "timezone" : "{{ event.timezone }}",
          "on_failure" : [
            {
              "append" : {
                "field" : "error.message",
                "value" : "{{ _ingest.on_failure_message }}"
              }
            }
          ],
          "if" : "ctx.event.timezone != null",
          "field" : "haproxy.request_date"
        }
      },
      {
        "remove" : {
          "field" : "haproxy.request_date"
        }
      },
      {
        "remove" : {
          "field" : "message"
        }
      },
      {
        "grok" : {
          "patterns" : [
            "^%{IP:source.ip}$"
          ],
          "field" : "source.address",
          "ignore_failure" : true
        }
      },
      {
        "geoip" : {
          "ignore_missing" : true,
          "field" : "source.ip",
          "target_field" : "source.geo"
        }
      },
      {
        "geoip" : {
          "field" : "source.ip",
          "target_field" : "source.as",
          "properties" : [
            "asn",
            "organization_name"
          ],
          "ignore_missing" : true,
          "database_file" : "GeoLite2-ASN.mmdb"
        }
      },
      {
        "rename" : {
          "target_field" : "source.as.number",
          "ignore_missing" : true,
          "field" : "source.as.asn"
        }
      },
      {
        "rename" : {
          "target_field" : "source.as.organization.name",
          "ignore_missing" : true,
          "field" : "source.as.organization_name"
        }
      },
      {
        "split" : {
          "field" : "haproxy.http.request.captured_headers",
          "separator" : "\\|",
          "ignore_failure" : true
        }
      },
      {
        "split" : {
          "separator" : "\\|",
          "ignore_failure" : true,
          "field" : "haproxy.http.response.captured_headers"
        }
      },
      {
        "script" : {
          "params" : {
            "scale" : 1000000
          },
          "if" : "ctx.temp?.duration != null",
          "lang" : "painless",
          "source" : "ctx.event.duration = Math.round(ctx.temp.duration * params.scale)"
        }
      },
      {
        "remove" : {
          "field" : "temp.duration",
          "ignore_missing" : true
        }
      },
      {
        "convert" : {
          "field" : "haproxy.bytes_read",
          "target_field" : "http.response.bytes",
          "type" : "long",
          "if" : "ctx.containsKey('http')"
        }
      },
      {
        "append" : {
          "field" : "related.ip",
          "value" : "{{source.ip}}",
          "if" : "ctx?.source?.ip != null"
        }
      },
      {
        "append" : {
          "field" : "related.ip",
          "value" : "{{destination.ip}}",
          "if" : "ctx?.destination?.ip != null"
        }
      },
      {
        "set" : {
          "value" : "event",
          "field" : "event.kind"
        }
      },
      {
        "append" : {
          "if" : "ctx?.haproxy?.mode == 'HTTP' || ctx?.haproxy?.http != null",
          "field" : "event.category",
          "value" : "web"
        }
      },
      {
        "append" : {
          "field" : "event.category",
          "value" : "network",
          "if" : "ctx?.source.ip != null && ctx?.destination?.ip != null"
        }
      },
      {
        "append" : {
          "field" : "event.type",
          "value" : "connection",
          "if" : "ctx?.source.ip != null && ctx?.destination?.ip != null"
        }
      },
      {
        "set" : {
          "field" : "event.outcome",
          "value" : "success",
          "if" : "ctx?.http?.response?.status_code != null && ctx.http.response.status_code < 400"
        }
      },
      {
        "set" : {
          "field" : "event.outcome",
          "value" : "failure",
          "if" : "ctx?.http?.response?.status_code != null && ctx.http.response.status_code >= 400"
        }
      }
    ],
    "on_failure" : [
      {
        "set" : {
          "field" : "error.message",
          "value" : "{{ _ingest.on_failure_message }}"
        }
      }
    ]
  },
  "filebeat-7.10.0-nginx-access-pipeline" : {
    "description" : "Pipeline for parsing Nginx access logs. Requires the geoip and user_agent plugins.",
    "processors" : [
      {
        "set" : {
          "field" : "event.ingested",
          "value" : "{{_ingest.timestamp}}"
        }
      },
      {
        "grok" : {
          "field" : "message",
          "patterns" : [
            "(%{NGINX_HOST} )?\"?(?:%{NGINX_ADDRESS_LIST:nginx.access.remote_ip_list}|%{NOTSPACE:source.address}) - (-|%{DATA:user.name}) \\[%{HTTPDATE:nginx.access.time}\\] \"%{DATA:nginx.access.info}\" %{NUMBER:http.response.status_code:long} %{NUMBER:http.response.body.bytes:long} \"(-|%{DATA:http.request.referrer})\" \"(-|%{DATA:user_agent.original})\""
          ],
          "pattern_definitions" : {
            "NGINX_NOTSEPARATOR" : "[^\t ,:]+",
            "NGINX_ADDRESS_LIST" : "(?:%{IP}|%{WORD})(\"?,?\\s*(?:%{IP}|%{WORD}))*",
            "NGINX_HOST" : "(?:%{IP:destination.ip}|%{NGINX_NOTSEPARATOR:destination.domain})(:%{NUMBER:destination.port})?"
          },
          "ignore_missing" : true
        }
      },
      {
        "grok" : {
          "field" : "nginx.access.info",
          "patterns" : [
            "%{WORD:http.request.method} %{DATA:url.original} HTTP/%{NUMBER:http.version}",
            ""
          ],
          "ignore_missing" : true
        }
      },
      {
        "remove" : {
          "field" : "nginx.access.info"
        }
      },
      {
        "split" : {
          "ignore_missing" : true,
          "field" : "nginx.access.remote_ip_list",
          "separator" : "\"?,?\\s+"
        }
      },
      {
        "split" : {
          "ignore_missing" : true,
          "field" : "nginx.access.origin",
          "separator" : "\"?,?\\s+"
        }
      },
      {
        "set" : {
          "field" : "source.address",
          "if" : "ctx.source?.address == null",
          "value" : ""
        }
      },
      {
        "script" : {
          "source" : "boolean isPrivate(def dot, def ip) {\n  try {\n    StringTokenizer tok = new StringTokenizer(ip, dot);\n    int firstByte = Integer.parseInt(tok.nextToken());\n    int secondByte = Integer.parseInt(tok.nextToken());\n    if (firstByte == 10) {\n      return true;\n    }\n    if (firstByte == 192 && secondByte == 168) {\n      return true;\n    }\n    if (firstByte == 172 && secondByte >= 16 && secondByte <= 31) {\n      return true;\n    }\n    if (firstByte == 127) {\n      return true;\n    }\n    return false;\n  }\n  catch (Exception e) {\n    return false;\n  }\n} try {\n  ctx.source.address = null;\n  if (ctx.nginx.access.remote_ip_list == null) {\n    return;\n  }\n  def found = false;\n  for (def item : ctx.nginx.access.remote_ip_list) {\n    if (!isPrivate(params.dot, item)) {\n      ctx.source.address = item;\n      found = true;\n      break;\n    }\n  }\n  if (!found) {\n    ctx.source.address = ctx.nginx.access.remote_ip_list[0];\n  }\n} catch (Exception e) {\n  ctx.source.address = null;\n}",
          "params" : {
            "dot" : "."
          },
          "if" : "ctx.nginx?.access?.remote_ip_list != null && ctx.nginx.access.remote_ip_list.length > 0",
          "lang" : "painless"
        }
      },
      {
        "remove" : {
          "field" : "source.address",
          "if" : "ctx.source.address == null"
        }
      },
      {
        "grok" : {
          "ignore_failure" : true,
          "field" : "source.address",
          "patterns" : [
            "^%{IP:source.ip}$"
          ]
        }
      },
      {
        "remove" : {
          "field" : "message"
        }
      },
      {
        "rename" : {
          "field" : "@timestamp",
          "target_field" : "event.created"
        }
      },
      {
        "date" : {
          "field" : "nginx.access.time",
          "target_field" : "@timestamp",
          "formats" : [
            "dd/MMM/yyyy:H:m:s Z"
          ],
          "on_failure" : [
            {
              "append" : {
                "field" : "error.message",
                "value" : "{{ _ingest.on_failure_message }}"
              }
            }
          ]
        }
      },
      {
        "remove" : {
          "field" : "nginx.access.time"
        }
      },
      {
        "user_agent" : {
          "field" : "user_agent.original",
          "ignore_missing" : true
        }
      },
      {
        "geoip" : {
          "ignore_missing" : true,
          "field" : "source.ip",
          "target_field" : "source.geo"
        }
      },
      {
        "geoip" : {
          "database_file" : "GeoLite2-ASN.mmdb",
          "field" : "source.ip",
          "target_field" : "source.as",
          "properties" : [
            "asn",
            "organization_name"
          ],
          "ignore_missing" : true
        }
      },
      {
        "rename" : {
          "ignore_missing" : true,
          "field" : "source.as.asn",
          "target_field" : "source.as.number"
        }
      },
      {
        "rename" : {
          "ignore_missing" : true,
          "field" : "source.as.organization_name",
          "target_field" : "source.as.organization.name"
        }
      },
      {
        "set" : {
          "field" : "event.kind",
          "value" : "event"
        }
      },
      {
        "append" : {
          "field" : "event.category",
          "value" : "web"
        }
      },
      {
        "append" : {
          "field" : "event.type",
          "value" : "access"
        }
      },
      {
        "set" : {
          "value" : "success",
          "if" : "ctx?.http?.response?.status_code != null && ctx.http.response.status_code < 400",
          "field" : "event.outcome"
        }
      },
      {
        "set" : {
          "value" : "failure",
          "if" : "ctx?.http?.response?.status_code != null && ctx.http.response.status_code >= 400",
          "field" : "event.outcome"
        }
      },
      {
        "append" : {
          "field" : "related.ip",
          "value" : "{{source.ip}}",
          "if" : "ctx?.source?.ip != null"
        }
      },
      {
        "append" : {
          "field" : "related.ip",
          "value" : "{{destination.ip}}",
          "if" : "ctx?.destination?.ip != null"
        }
      },
      {
        "append" : {
          "if" : "ctx?.user?.name != null",
          "field" : "related.user",
          "value" : "{{user.name}}"
        }
      }
    ],
    "on_failure" : [
      {
        "set" : {
          "field" : "error.message",
          "value" : "{{ _ingest.on_failure_message }}"
        }
      }
    ]
  },
  "apm_remove_span_metadata" : {
    "description" : "Removes metadata fields available already on the parent transaction, to save storage",
    "processors" : [
      {
        "remove" : {
          "field" : [
            "host",
            "process",
            "user",
            "user_agent",
            "container",
            "kubernetes",
            "service.node",
            "service.version",
            "service.language",
            "service.runtime",
            "service.framework"
          ],
          "ignore_missing" : true,
          "ignore_failure" : true,
          "if" : "ctx.processor?.event == 'span'"
        }
      }
    ]
  },
  "filebeat-7.10.0-apache-access-pipeline" : {
    "processors" : [
      {
        "set" : {
          "field" : "event.ingested",
          "value" : "{{_ingest.timestamp}}"
        }
      },
      {
        "grok" : {
          "field" : "message",
          "patterns" : [
            "%{IPORHOST:destination.domain} %{IPORHOST:source.ip} - %{DATA:user.name} \\[%{HTTPDATE:apache.access.time}\\] \"(?:%{WORD:http.request.method} %{DATA:url.original} HTTP/%{NUMBER:http.version}|-)?\" %{NUMBER:http.response.status_code:long} (?:%{NUMBER:http.response.body.bytes:long}|-)( \"%{DATA:http.request.referrer}\")?( \"%{DATA:user_agent.original}\")?",
            "%{IPORHOST:source.address} - %{DATA:user.name} \\[%{HTTPDATE:apache.access.time}\\] \"(?:%{WORD:http.request.method} %{DATA:url.original} HTTP/%{NUMBER:http.version}|-)?\" %{NUMBER:http.response.status_code:long} (?:%{NUMBER:http.response.body.bytes:long}|-)( \"%{DATA:http.request.referrer}\")?( \"%{DATA:user_agent.original}\")?",
            "%{IPORHOST:source.address} - %{DATA:user.name} \\[%{HTTPDATE:apache.access.time}\\] \"-\" %{NUMBER:http.response.status_code:long} -",
            "\\[%{HTTPDATE:apache.access.time}\\] %{IPORHOST:source.address} %{DATA:apache.access.ssl.protocol} %{DATA:apache.access.ssl.cipher} \"%{WORD:http.request.method} %{DATA:url.original} HTTP/%{NUMBER:http.version}\" (-|%{NUMBER:http.response.body.bytes:long})"
          ],
          "ignore_missing" : true
        }
      },
      {
        "remove" : {
          "field" : "message"
        }
      },
      {
        "set" : {
          "field" : "event.kind",
          "value" : "event"
        }
      },
      {
        "set" : {
          "field" : "event.category",
          "value" : "web"
        }
      },
      {
        "set" : {
          "if" : "ctx?.http?.response?.status_code != null && ctx.http.response.status_code < 400",
          "field" : "event.outcome",
          "value" : "success"
        }
      },
      {
        "set" : {
          "field" : "event.outcome",
          "value" : "failure",
          "if" : "ctx?.http?.response?.status_code != null && ctx.http.response.status_code > 399"
        }
      },
      {
        "grok" : {
          "patterns" : [
            "^(%{IP:source.ip}|%{HOSTNAME:source.domain})$"
          ],
          "field" : "source.address",
          "ignore_missing" : true
        }
      },
      {
        "rename" : {
          "target_field" : "event.created",
          "field" : "@timestamp"
        }
      },
      {
        "date" : {
          "ignore_failure" : true,
          "field" : "apache.access.time",
          "target_field" : "@timestamp",
          "formats" : [
            "dd/MMM/yyyy:H:m:s Z"
          ]
        }
      },
      {
        "remove" : {
          "field" : "apache.access.time",
          "ignore_failure" : true
        }
      },
      {
        "user_agent" : {
          "field" : "user_agent.original",
          "ignore_failure" : true
        }
      },
      {
        "geoip" : {
          "field" : "source.ip",
          "target_field" : "source.geo",
          "ignore_missing" : true
        }
      },
      {
        "geoip" : {
          "field" : "source.ip",
          "target_field" : "source.as",
          "properties" : [
            "asn",
            "organization_name"
          ],
          "ignore_missing" : true,
          "database_file" : "GeoLite2-ASN.mmdb"
        }
      },
      {
        "rename" : {
          "field" : "source.as.asn",
          "target_field" : "source.as.number",
          "ignore_missing" : true
        }
      },
      {
        "rename" : {
          "field" : "source.as.organization_name",
          "target_field" : "source.as.organization.name",
          "ignore_missing" : true
        }
      },
      {
        "set" : {
          "field" : "tls.cipher",
          "value" : "{{apache.access.ssl.cipher}}",
          "ignore_empty_value" : true
        }
      },
      {
        "script" : {
          "if" : "ctx?.apache?.access?.ssl?.protocol != null",
          "source" : "def parts = ctx.apache.access.ssl.protocol.toLowerCase().splitOnToken(\"v\"); if (parts.length != 2) {\n  return;\n} if (parts[1].contains(\".\")) {\n  ctx.tls.version = parts[1];\n} else {\n  ctx.tls.version = parts[1] + \".0\";\n} ctx.tls.version_protocol = parts[0];",
          "lang" : "painless"
        }
      }
    ],
    "on_failure" : [
      {
        "set" : {
          "field" : "error.message",
          "value" : "{{ _ingest.on_failure_message }}"
        }
      }
    ],
    "description" : "Pipeline for parsing Apache HTTP Server access logs. Requires the geoip and user_agent plugins."
  },
  "filebeat-7.10.0-apache-error-pipeline" : {
    "description" : "Pipeline for parsing apache error logs",
    "processors" : [
      {
        "set" : {
          "field" : "event.ingested",
          "value" : "{{_ingest.timestamp}}"
        }
      },
      {
        "grok" : {
          "field" : "message",
          "patterns" : [
            "\\[%{APACHE_TIME:apache.error.timestamp}\\] \\[%{LOGLEVEL:log.level}\\]( \\[client %{IPORHOST:source.address}(:%{POSINT:source.port})?\\])? %{GREEDYDATA:message}",
            "\\[%{APACHE_TIME:apache.error.timestamp}\\] \\[%{DATA:apache.error.module}:%{LOGLEVEL:log.level}\\] \\[pid %{NUMBER:process.pid:long}(:tid %{NUMBER:process.thread.id:long})?\\]( \\[client %{IPORHOST:source.address}(:%{POSINT:source.port})?\\])? %{GREEDYDATA:message}"
          ],
          "pattern_definitions" : {
            "APACHE_TIME" : "%{DAY} %{MONTH} %{MONTHDAY} %{TIME} %{YEAR}"
          },
          "ignore_missing" : true
        }
      },
      {
        "date" : {
          "formats" : [
            "EEE MMM dd H:m:s yyyy",
            "EEE MMM dd H:m:s.SSSSSS yyyy"
          ],
          "on_failure" : [
            {
              "append" : {
                "field" : "error.message",
                "value" : "{{ _ingest.on_failure_message }}"
              }
            }
          ],
          "if" : "ctx.event.timezone == null",
          "field" : "apache.error.timestamp",
          "target_field" : "@timestamp"
        }
      },
      {
        "date" : {
          "on_failure" : [
            {
              "append" : {
                "field" : "error.message",
                "value" : "{{ _ingest.on_failure_message }}"
              }
            }
          ],
          "if" : "ctx.event.timezone != null",
          "field" : "apache.error.timestamp",
          "target_field" : "@timestamp",
          "formats" : [
            "EEE MMM dd H:m:s yyyy",
            "EEE MMM dd H:m:s.SSSSSS yyyy"
          ],
          "timezone" : "{{ event.timezone }}"
        }
      },
      {
        "remove" : {
          "field" : "apache.error.timestamp",
          "ignore_failure" : true
        }
      },
      {
        "set" : {
          "field" : "event.kind",
          "value" : "event"
        }
      },
      {
        "set" : {
          "value" : "web",
          "field" : "event.category"
        }
      },
      {
        "script" : {
          "if" : "ctx?.log?.level != null",
          "lang" : "painless",
          "source" : "def err_levels = [\"emerg\", \"alert\", \"crit\", \"error\", \"warn\"]; if (err_levels.contains(ctx.log.level)) {\n  ctx.event.type = \"error\";\n} else {\n  ctx.event.type = \"info\";\n}"
        }
      },
      {
        "grok" : {
          "patterns" : [
            "^(%{IP:source.ip}|%{HOSTNAME:source.domain})$"
          ],
          "field" : "source.address",
          "ignore_missing" : true
        }
      },
      {
        "geoip" : {
          "field" : "source.ip",
          "target_field" : "source.geo",
          "ignore_missing" : true
        }
      },
      {
        "geoip" : {
          "database_file" : "GeoLite2-ASN.mmdb",
          "field" : "source.ip",
          "target_field" : "source.as",
          "properties" : [
            "asn",
            "organization_name"
          ],
          "ignore_missing" : true
        }
      },
      {
        "rename" : {
          "field" : "source.as.asn",
          "target_field" : "source.as.number",
          "ignore_missing" : true
        }
      },
      {
        "rename" : {
          "field" : "source.as.organization_name",
          "target_field" : "source.as.organization.name",
          "ignore_missing" : true
        }
      }
    ],
    "on_failure" : [
      {
        "set" : {
          "field" : "error.message",
          "value" : "{{ _ingest.on_failure_message }}"
        }
      }
    ]
  },
  "apm" : {
    "description" : "Default enrichment for APM events",
    "processors" : [
      {
        "pipeline" : {
          "name" : "apm_user_agent"
        }
      },
      {
        "pipeline" : {
          "name" : "apm_user_geo"
        }
      },
      {
        "pipeline" : {
          "name" : "apm_ingest_timestamp"
        }
      },
      {
        "pipeline" : {
          "name" : "apm_remove_span_metadata"
        }
      }
    ]
  },
  "apm_user_agent" : {
    "description" : "Add user agent information for APM events",
    "processors" : [
      {
        "user_agent" : {
          "field" : "user_agent.original",
          "target_field" : "user_agent",
          "ignore_missing" : true,
          "ignore_failure" : true
        }
      }
    ]
  }
}
